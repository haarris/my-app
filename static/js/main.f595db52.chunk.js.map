{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.jsx","App.js","reportWebVitals.js","index.js"],"names":["Card","props","className","alt","src","monster","id","name","email","CardList","monsters","map","SearchBox","placeholder","handleChange","type","onChange","App","state","searchField","fetch","then","response","json","users","setState","this","filteredMonsters","filter","toLowerCase","includes","e","target","value","Component","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"iSAIaA,G,YAAO,SAACC,GAAD,OAChB,sBAAKC,UAAU,iBAAf,UACI,qBAAKC,IAAI,UAAUC,IAAG,+BAA0BH,EAAMI,QAAQC,GAAxC,4BACtB,mCAAML,EAAMI,QAAQE,QACpB,mCAAMN,EAAMI,QAAQG,MAApB,YCOKC,EAAW,SAACR,GAAD,OAIpB,aAJgC,CAIhC,OAAKC,UAAU,YAAf,SACOD,EAAMS,SAASC,KAAI,SAAAN,GAAO,OAEzB,aADA,CACC,EAAD,CAAuBA,QAASA,GAArBA,EAAQC,UCZlBM,G,YAAY,SAAC,GAAD,IAAGC,EAAH,EAAGA,YAAaC,EAAhB,EAAgBA,aAAhB,OAErB,aADJ,CACI,SACIC,KAAK,SACLF,YAAcA,EACdX,UAAU,SACVc,SAAUF,MC2DHG,E,kDAhEb,aAAe,IAAD,8BACZ,gBACKC,MAAQ,CACXR,SAAU,GAeVS,YAAa,IAlBH,E,gEAwBO,IAAD,OAClBC,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAE1BF,MAAK,SAAAG,GAAK,OAAI,EAAKC,SAAS,CAAEf,SAAUc,S,+BAEjC,IAAD,SAC0BE,KAAKR,MAA9BR,EADD,EACCA,SAAUS,EADX,EACWA,YAGZQ,EAAmBjB,EAASkB,QAAO,SAAAvB,GAAO,OAC9CA,EAAQE,KAAKsB,cAAcC,SAASX,EAAYU,kBAElD,OAME,cANM,CAMN,OAAK3B,UAAU,MAAf,UACE,kDACA,cAAC,EAAD,CACEW,YAAY,kBACZC,aAAe,SAAAiB,GAAC,OAAI,EAAKN,SAAS,CAAEN,YAAaY,EAAEC,OAAOC,WAE5D,cAAC,EAAD,CAAUvB,SAAUiB,W,GAtDVO,aCMHC,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBhB,MAAK,YAAkD,IAA/CiB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCCdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.f595db52.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport './card.styles.css';\r\n\r\nexport const Card = (props) => (\r\n    <div className='card-container'>\r\n        <img alt=\"monster\" src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`}/>\r\n        <h2> {props.monster.name}</h2>\r\n        <h2> {props.monster.email} </h2>\r\n    </div>\r\n);","/*\r\nThis is one big component to hold all the other components, such as \r\nthe individual monsters and ordering the structure and maybe design too\r\n\r\nNow we can also use this component for other things, so always:\r\nBREAK THINGS DOWN, into tiny tiny pieces called COMPONENTS, which\r\nwe can COMBINE to their relevant CONCERNS\r\n*/\r\n\r\nimport React from 'react';\r\n\r\nimport './card-list.styles.css';\r\nimport '../card/card.component';\r\nimport { Card } from '../card/card.component';\r\n\r\nexport const CardList = (props) => (//object comes from React\r\n//    console.log(props);\r\n//    console.log(`This is props.children: ${props.children}`);\r\n//'card-list' from card.list.styles.css\r\n    <div className='card-list'> \r\n          {props.monsters.map(monster =>( \r\n            //<h1 key={monster.id}> {monster.name}</h1> //REPLACED BY\r\n            <Card key={monster.id} monster={monster}/>\r\n            //good rule of thumb to use key attribute whenever mapping thru\r\n            //a list in render() since React needs a unique key for each\r\n          ))}    \r\n    </div>\r\n    //{props.children} has to be curly braces due to it pushing thru JS\r\n    //i.e. not a simple <h1> tag but entire map function JS code etc\r\n    //'card-list' is the classname which the css file also references\r\n);","import React from 'react';\r\n\r\nimport './search-box.styles.css';\r\n\r\n\r\n/* functional components don't have access to state, or lifecycle methods\r\nunlike class components, hence used for largely returning html (via \r\n    taking in props)\r\n\r\n*/\r\nexport const SearchBox = ({ placeholder, handleChange }) => (\r\n//                  remember how you could pass thru props?\r\n    <input \r\n        type='search'\r\n        placeholder={ placeholder }\r\n        className='search'\r\n        onChange={handleChange}\r\n   />\r\n);\r\n/*Why not put State here?\r\nBecause remember 'One Way Dataflow' that the top most part of the tree-like\r\nData structure is the best place to put it since the bottom majority can\r\neasily find the refreshed state, if we do it solely on searchbox, then \r\nit's not at the top, way down, and if it did it both at the same time, then\r\nconfusing and potentially conflicting states down the line.\r\nResearch more on React architecture  theory as well, get Data Structures\r\nright. \r\n*/\r\n\r\n\r\n\r\n/*OLD BEFORE CONVERTED INTO COMPONENT\r\n\r\nconst searchBox = ({ placeholder }) => {\r\n    <input type='search' placeholder={ placeholder } className='search'\r\n       onChange={e => { //synthetic event via react DOM\r\n       //console.log(e.target.value)} //default e.target\r\n       this.setState({ searchField: e.target.value }//, () =>\r\n//           console.log(this.state)\r\n       ); //we're doing it in this fashion (i.e. console.log as callback)\r\n         //bcos setState is async (vs sync) hence it doesn't return entire\r\n         //input immediately (lag of 1 unit), but callback takes care of this\r\n    }} \r\n   />\r\n}\r\n*/","import { Component } from 'react';\r\n//import { unmountComponentAtNode } from 'react-dom';\r\nimport { CardList } from './components/card-list/card-list.component';\r\nimport './App.css';\r\nimport { SearchBox } from '../src/components/search-box/search-box';\r\n\r\nclass App extends Component { \r\n/* Using a Class component gains us access to 'state' which is big JS\r\nobject w/ props which we can access anytime inside our class \r\nand also the 'setState' method on ANY HTML\r\n*/\r\n  constructor() { \r\n    super();//calls the constructor method on the component class\r\n    this.state = {//hence allows us access to the state in our class\r\n      monsters: [\r\n        /*{ //need to keep empty since we're fetching data anyway\r\n          name: 'Frankenstein',\r\n          id: 'asdfkey1' //react needs a unique key for each, for quick\r\n                        //calling and in case state changes the name\r\n        },\r\n        {\r\n          name: 'Dracula',\r\n          id: 'asdfkey2'\r\n        },\r\n        {\r\n          name: 'Zombie',\r\n          id: 'asdfkey3'\r\n        } */\r\n      ],\r\n      searchField: ''\r\n    };\r\n  }\r\n  //life cycle methods are methods of the components dependent on specific\r\n  //times or events\r\n  \r\n  componentDidMount() {\r\n    fetch('https://jsonplaceholder.typicode.com/users')\r\n    .then(response => response.json())\r\n    //.then(users => console.log(users));\r\n    .then(users => this.setState({ monsters: users}));\r\n  }\r\n  render() { //from Component\r\n    const { monsters, searchField} = this.state; //destructuring\r\n    //equivalent to:   const monsters = this.state.monsters;\r\n    //                 const searchField = this.state.searchField;\r\n    const filteredMonsters = monsters.filter(monster => \r\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\r\n    );\r\n    return (//what is below is HTML/JSX (hence comments don't work)\r\n/*JSX is trying to mimic HTML, in order to utilise as virtualDOM but you'll\r\nstill see small diffs like 'className' (classname) and 'button onClick=' \r\n<button onclick=src>, this is cos JSX is primarily JS and hence camelCase is\r\nused instead*/\r\n\r\n      <div className=\"App\" >\r\n        <h1>Monsters Rolodex</h1>\r\n        <SearchBox\r\n          placeholder='search monsters'\r\n          handleChange ={e => this.setState({ searchField: e.target.value})}\r\n        />\r\n        <CardList monsters={filteredMonsters} />\r\n      </div>\r\n      /*this.state.monsters (and whenever state is ref'd in places like here)\r\n      is passed down as 'props' hence why setState is so important cos:\r\n/* why setState? Because unidirectional data flow, cannot access state\r\ndirectly, hence whenever button is clicked and state is adjusted, the \r\nrender() method is called again, state is updated etc -> declarative approach\r\n      so all the components (read: functions) that take in props via state, \r\n      all end up refreshing via new state (read: new props), hence important \r\n      via rule 2) 'decide on where/how state lives/runs'\r\n*/\r\n    );\r\n  }\r\n}\r\n\r\nexport default App; \r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n//interacts with the DOM whereas App.js where React is imported\n//IS the actual VirtualDOM\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}